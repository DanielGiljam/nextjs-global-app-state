import {IncomingMessage} from "http"

import {Context, Provider} from "react"

import GlobalAppStateError, {GlobalAppStateErrors} from "./GlobalAppStateError"

import {Cookies, CookieConsent} from "../util/cookies"

export type PropertyValueType = any // eslint-disable-line @typescript-eslint/no-explicit-any

export type ContextValueType = any // eslint-disable-line @typescript-eslint/no-explicit-any

export type GlobalAppStatePropertySetter<
  T = PropertyValueType,
  C = ContextValueType
> = (
  values: Set<T>,
  cookieConsent: CookieConsent,
  value: T
) => Promise<C | void>

export type GlobalAppStatePropertySetterProxy<T = PropertyValueType> = (
  value: T
) => void

/**
 * This is how you describe a global app state property.
 * We're talking about an object literal that has
 * certain properties defined on it.
 */
export interface GlobalAppStatePropertyParameters<
  T = PropertyValueType,
  C = ContextValueType
> {
  /**
   * This will be the name of your global app state property.
   */
  key: string;
  /**
   * A custom plural form for the `key` of your global app state property.
   * If you don't like the plural form generated by the library based
   * on the `key`, then you can specify how the plural form should look
   * here.
   */
  keyPlural?: string;
  /**
   * A default state value for your global app state property
   * to fall back to if all attempts initializing/restoring
   * state would fail. Must be a valid value — or in other
   * words, the value must exist in `defaultValues`.
   */
  defaultValue: T;
  /**
   * A set of values enumerating the states that will be regarded
   * as valid states for your global app state property to be in.
   */
  defaultValues: Set<T>;
  /**
   * An object literal containing functions that initialize/restore
   * the state of your global app state property, server-side and
   * client-side respectively.
   */
  initializeValue?: {
    /**
     * A function for initializing/restoring the state of your
     * global app state property server-side when performing
     * an on-demand server-side render.
     * @param values A set of values enumerating the states that are regarded as valid states for your global app state property
     * @param defaultValue This global app state property's defaultValue
     * @param cookies An object literal representing any cookies sent with the client's request
     * @param req The request itself
     * @returns A valid state value synchronously or asynchronously
     */
    serverSide?(
      values?: Set<T>,
      defaultValue?: T,
      cookies?: Cookies,
      req?: IncomingMessage
    ): T | Promise<T>;
    /**
     * A function for initializing/restoring the state of your
     * global app state property client-side when the `App`
     * component has mounted.
     * @param values A set of values enumerating the states that are regarded as valid states for your global app state property
     * @param existingValue A pre-existing state value or the `defaultValue`
     * @returns A valid state value synchronously or asynchronously
     */
    clientSide?(values?: Set<T>, existingValue?: T): T | Promise<T>;
  };
  /**
   * An object literal containing functions that retrieve a set
   * of values enumerating the states that will be regarded
   * as valid states for your global app state property.
   * The sets returned by these functions override
   * the `defaultValues`.
   */
  getValues?: {
    /**
     * A function for retrieving the set of values server-side.
     * @returns The set of values either synchronously or asynchronously
     */
    serverSide?(): Set<T> | Promise<Set<T>>;
    /**
     * A function for retrieving the set of values client-side.
     * @returns The set of values either synchronously or asynchronously
     */
    clientSide?(): Set<T> | Promise<Set<T>>;
  };
  /**
   * A function that gets invoked when the state of your
   * global app state property is explicitly changed.
   * The function must be asynchronous.
   * @param values A set of values enumerating the states that are regarded as valid states for your global app state property
   * @param cookieConsent Indicates whether the client has given consent to cookies or not
   * @param value The state value that your global app state property is being set to
   */
  setValue?(
    values: Set<T>,
    cookieConsent: CookieConsent,
    value: T
  ): Promise<void>;
  /**
   * Indicates that your global app state property should be
   * treated as sensitive information. Defaults to false.
   */
  isSensitiveInformation?: boolean;
  /**
   * An object literal. Lets you link your global app state property
   * to a `React.Context`, such that the state of your global app
   * state property controls what data is in the `Context`.
   * If controlContext is defined, `controlContext.Context`
   * and/or `controlContext.ContextProvider` must also be
   * defined.
   */
  controlContext?: {
    /**
     * A transformation that is applied to the state value of
     * your global app state property before it's placed into
     * the `Context`. The transformation can either be
     * synchronous or asynchronous, but if it's
     * asynchronous, you have to indicate it
     * using the `controlContext.isAsync`
     * flag.
     * @param value The state value of your global app state property
     * @returns The data that is placed into the `Context` either synchronously or asynchronously
     */
    transformValue?(value: T): C | Promise<C>;
    /**
     * Indicates that `controlContext.transformValue` is defined
     * and returns a `Promise` (is asynchronous).
     * Defaults to false.
     */
    isAsync?: boolean;
    /**
     * Indicates that `controlContext.transformValue` is defined
     * and returns or (if it's a `Promise`) resolves to something
     * that can be serialized server-side by Next.js and then
     * hydrated client-side. Defaults to false.
     */
    isSerializable?: boolean;
    /**
     * A `React.Context`.
     */
    context?: Context<C>;
    /**
     * It doesn't strictly have to be a `Context.Provider`.
     * It just has to be similar enough — more specifically,
     * it has to be a component that wraps its children
     * and takes a prop called `value`.
     */
    ContextProvider?: Provider<C>;
  };
}

export interface DehydratedGlobalAppStateProperty<
  T = PropertyValueType,
  C = ContextValueType
> {
  value: T;
  values: T[];
  serializedContext?: C;
}

export type HydratedGlobalAppStatePropertyType<T = PropertyValueType> =
  | T
  | Set<T>
  | GlobalAppStatePropertySetterProxy<T>

class GlobalAppStateProperty<T = PropertyValueType, C = ContextValueType> {
  readonly key: string
  readonly keyPlural: string
  readonly setterName: string
  readonly isSensitiveInformation?: boolean

  private readonly initializeValue?: {
    serverSide?(
      values?: Set<T>,
      defaultValue?: T,
      cookies?: Cookies,
      req?: IncomingMessage
    ): T | Promise<T>;
    clientSide?(values?: Set<T>, existingValue?: T): T | Promise<T>;
  }
  private readonly getValues?: {
    serverSide?(): Set<T> | Promise<Set<T>>;
    clientSide?(): Set<T> | Promise<Set<T>>;
  }
  private setValue?(
    values: Set<T>,
    cookieConsent: CookieConsent,
    value: T
  ): Promise<void>
  private readonly controlContext?: {
    transformValue?(value: T): C | Promise<C>;
    isAsync?: boolean;
    isSerializable?: boolean;
    context?: Context<C>;
    ContextProvider?: Provider<C>;
  }

  private state: {
    value: T;
    values: Set<T>;
    contextValue?: C;
  }

  constructor({
    key,
    keyPlural,
    defaultValue,
    defaultValues,
    ...parameters
  }: GlobalAppStatePropertyParameters<T, C>) {
    if (defaultValues.has(defaultValue)) {
      this.key = key
      this.keyPlural = keyPlural || key + "s"
      this.setterName = key.replace(
          /^./,
          (match) => `set${match.toUpperCase()}`,
      )
      this.state = {
        value: defaultValue,
        values: defaultValues,
      }
      Object.entries(parameters).forEach(([key, value]) => {
        this[key as keyof this] = value
      })
    } else {
      throw new GlobalAppStateError(
          GlobalAppStateErrors.PROPERTY_CONSTRUCTION_ERROR,
          key,
      )
    }
  }

  async initializeStateServerSide(
      cookies: Cookies,
      req: IncomingMessage,
  ): Promise<void> {
    if (this.getValues?.serverSide) {
      this.state.values = await this.getValues.serverSide()
    }
    if (this.initializeValue?.serverSide) {
      this.state.value = await this.initializeValue.serverSide(
          this.state.values,
          this.state.value,
          cookies,
          req,
      )
    }
    if (this.controlContext?.isSerializable) {
      if (this.controlContext.transformValue) {
        this.state.contextValue = await this.controlContext.transformValue(
            this.state.value,
        )
      } else {
        GlobalAppStateError.warn(
            GlobalAppStateErrors.AMBIGUOUS_IS_SERIALIZABLE,
            this.key,
        )
        this.state.contextValue = (this.state.value as unknown) as C
      }
    }
  }

  injectDehydratedState({
    value,
    values,
    serializedContext,
  }: DehydratedGlobalAppStateProperty<T, C>): void {
    this.state = {
      value,
      values: new Set<T>(values),
      contextValue: serializedContext,
    }
    if (
      !this.controlContext?.isSerializable &&
      !this.controlContext?.isAsync &&
      this.controlContext
    ) {
      if (this.controlContext.transformValue) {
        this.state.contextValue = this.controlContext.transformValue(value) as C
      } else {
        this.state.contextValue = (value as unknown) as C
      }
    }
  }

  async initializeStateClientSide(
      existingValue: T,
      existingValues: Set<T>,
  ): Promise<void> {
    if (this.getValues?.clientSide) {
      this.state.values = await this.getValues.clientSide()
    } else {
      this.state.values = existingValues
    }
    if (this.initializeValue?.clientSide) {
      this.state.value = await this.initializeValue.clientSide(
          this.state.values,
          existingValue,
      )
    } else {
      this.state.value = existingValue
    }
    if (!this.controlContext?.isSerializable && this.controlContext?.isAsync) {
      if (this.controlContext.transformValue) {
        this.state.contextValue = await this.controlContext.transformValue(
            this.state.value,
        )
      } else {
        GlobalAppStateError.warn(
            GlobalAppStateErrors.AMBIGUOUS_IS_ASYNC,
            this.key,
        )
        this.state.contextValue = (this.state.value as unknown) as C
      }
    } else if (this.state.value !== existingValue) {
      if (this.controlContext?.transformValue) {
        this.state.contextValue = await this.controlContext.transformValue(
            this.state.value,
        )
      }
    } else {
      this.state.contextValue = undefined
    }
  }

  get value(): T {
    return this.state.value
  }

  get values(): Set<T> {
    return this.state.values
  }

  get setter(): GlobalAppStatePropertySetter<T, C> {
    if (this.setValue) {
      const setValue = this.setValue
      if (this.controlContext) {
        if (this.controlContext.transformValue) {
          const transformValue = this.controlContext.transformValue
          return (
              values: Set<T>,
              cookieConsent: CookieConsent,
              value,
          ): Promise<C> =>
            setValue(values, cookieConsent, value).then(() =>
              transformValue(value),
            )
        }
        return (
            values: Set<T>,
            cookieConsent: CookieConsent,
            value,
        ): Promise<C> =>
          setValue(values, cookieConsent, value).then(
              () => (value as unknown) as C,
          )
      }
      return setValue
    }
    return async (): Promise<undefined> => undefined
  }

  get contextValue(): C | undefined {
    return this.state.contextValue
  }

  get ContextProvider(): Provider<C> | undefined {
    return (
      this.controlContext?.ContextProvider ||
      this.controlContext?.context?.Provider ||
      undefined
    )
  }
}

export default GlobalAppStateProperty
